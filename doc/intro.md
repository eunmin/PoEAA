# 엔터프라이즈 애플리케이션 아키텍처 패턴

## 관계형 데이터베이스 매핑

SQL과 도메인 논리를 분리하는 것이 좋다. Gateway 방식은 테이블 당 클래스 하나를 갖는다.
상호배타적이지 않다.

### 행 데이터 게이트웨이 (Row Data Gateway)

쿼리 결과 Row 하나를 Gateway 클래스 하나로 매핑한다. Gateway 클래스는 직접 insert, update,
delete 작업을 하고 조회 작업의 경우 Finder 클래스로 분리하는 경우가 있다. Finder 클래스는 Gateway에
의존성을 가지고 있고 Gateway 클래스는 load와 같은 메서드로 인스턴스 생성을 할 수 있는데 이때 load
클래스는 ResultSet과 같은 클래스에 의존성을 갖는다.

- 도메인 논리 패턴과 함께 사용할 때
  - 트랜젝션 스크립트 (Transaction Script)
    - 트랜젝션 스크립트에서 게이트웨이를 불러 사용한다.
  - 도메인 모델 (Domain Model)
    - 의존성(간접성)이 심하거나 부족?
  - 테이블 모듈 (Table Module)
    - 쓸 수 있지만 테이블 모듈에 게이트웨이 의존성이 생긴다.

### 테이블 데이터 게이트웨이 (Table Data Gateway)

행 데이터 게이트웨이가 데이터를 Gateway 클래스가 직접 가지고 있었다면 테이블 데이터 게이트웨이는
데이터를 표현하는 클래스를 별도로 둔다. 그 클래스는 ResultSet, Map 같은 범용 데이터 구조일 수도 있고
DTO나 도메인 모델이 될 수 있다. 도메인 모델인 경우 양방향 의존성이 생길 수 있어 피한다.

- 도메인 논리 패턴과 함께 사용할 때
  - 트랜젝션 스크립트 (Transaction Script)
    - 트랜젝션 스크립트에서 게이트웨이를 불러 사용한다.
  - 도메인 모델 (Domain Model)
    - 의존성(간접성)이 심하거나 부족?
  - 테이블 모듈 (Table Module)
    - 테이블 데이터 게이트웨이를 사용하는 경우 적합한 도메인 논리 패턴이다.
    - 테이블 데이터 게이트웨이를 사용하는 프레젠테이션 레이어에서 직접 테이블 모듈을 불러 도메인 논리를
      수행한다.
    - 저장 프로시저도 테이블 데이터 게이트웨이로 감출수 있다.

### 활성 레코드 (Active Record) - 도메인 논리 모델로 볼 수 도 있다.

구조적으로 행 데이터 게이트웨이에 도메인 논리가 추가되었다고 보면 된다. 도메인 모델이 간단한 경우 사용한다.

- 도메인 논리 패턴과 함께 사용할 때
  - 트랜젝션 스크립트 (Transaction Script)
    - 도메인 논리를 데이터 소스가 포함하기 때문에 사용할 수 없다.
  - 도메인 모델 (Domain Model)
    - 도메인 모델이 간단한 경우 사용가능하나 복잡한 리치 도메인 모델인 경우 테이블과 클래스 1:1 매핑이
      깨져 표현하기 어려워진다.
  - 테이블 모듈 (Table Module)
    - 도메인 논리를 데이터 소스가 포함하기 때문에 사용할 수 없다.

### 데이터 매퍼 (Data Mapper)

테이블과 도메인 모델이 일치하지 않는 경우 데이터베이스와 도메인 모델이 직접 연결되는 것을 끝고 중간 매퍼를
둔다. 도메인 모델을 사용한다면 게이트웨이 방식을 추천하지 않는다. 데이터 매퍼가 게이트웨이를 사용할 수 있다.

- 도메인 논리 패턴과 함께 사용할 때
  - 트랜젝션 스크립트 (Transaction Script)
  - 도메인 모델 (Domain Model)
  - 테이블 모듈 (Table Module)

## 동작 문제
- 객체, 테이블 매핑 보다 어렵다.
- 활성 레코드를 사용하면 확실하다.
- 객체를 읽고 수정하는 동안 데이터베이스 상태를 일관되게 유지해야한다.

### 작업 단위

애플리케이션에서 직접 데이터베이스 저장을 수행하지 않고 작업 단위를 커밋한다.

### 식별자 맵

- 같은 객체를 두번 읽어오지 않도록 식별자 맵을 사용한다.
- 이미 읽은 데이터라면 읽은 데이터를 반환한다.
- 혼동하지 말아야할 것은 식별자 맵은 주요 용도가 캐싱이 아니다.

### 지연 로드

- 도메인 모델에서 연관 객체를 모두 로드 하지 않고 필요할 때 로드 해야하는 경우가 많이 있다.

## 데이터 읽기

- 데이터를 읽는 메서드를 Finder라고 생각한다. (findXX, findForXXX 같은 이름의 메서드가 많다.)
- Finder 메서드를 두는 위치는
  - 테이블 데이터 게이트웨이 인 경우 게이트웨이에 두면 된다.
  - 행 데이터 게이트웨이 인 경우 static으로 만들 수 있지만 데이터베이스 작업을 다른 클래스로 대체 할
    수 없다. (서비스 스텁) 그래서 별도의 Finder 객체를 만드는 것이 좋다.
- Finder 클래스는 데이터베이스를 기준으로한다. (이미 로드된 객체를 또 로드 할 수 있다.)
- 성능 향상을 위해 여러 행을 읽어오거나 조인을 사용할 수 있지만 과하면 오히려 성능 저하가 된다.

## 구조적 매핑 패턴

- 테이블 데이터 게이트웨이를 사용하는 경우 필요 없다. (ResultSet이나 맵, DTO등을 사용하기 때문에..)
- 관계 매핑
  - 데이터베이스 테이블은 다른 테이블과 키로 연결되고 객체는 다른 객체와 참조로 연결된다.
  - 객체에 식별자 필드를 두고 데이터베이스 키를 매핑한다.
  - 식별자 필드로 데이터베이스를 조회한다. 조회할 때는 식별자 맵을 먼저 찾고 없으면 지연 로딩할 수 있다.
  - 컬렉션 처리는 복잡한데 외래 키 매핑 방법을 사용한다. 만약 컬렉션 추가/삭제가 되면 추가/삭제된 객체를
    인지해야하는 어려움이 있다.
  - 다대다 관계는 연관 테이블이 있기 때문에 다른 방법이 필요하다.
  - 테이블은 순서를 보장하지 않기 때문에 객체 컬렉션은 순서가 없는 타입을 사용하는 것이 좋다.
  - 값 객체는 식별자 필드가 필요 없다.
  - 객체를 통으로 직렬화 해서 저장하는 방법도 있는데 이는 부분쿼리가 없는 경우에 적합하다. (* JSON 필드?)
- 상속
  - 단일 테이블 상속
    - 계층의 모든 클래스를 하나의 테이블로 만든다.
    - 공간이 낭비 된다.
    - 수정하기 쉽고 조인이 필요 없다.
    - 타입 필드가 필요하다.
  - 클래스 테이블 상속
    - 클래스 단위로 테이블을 나눈다.
    - 관계를 단순하게 저장하지만 단일 객체 로드시 조인이 많이 필요하다.
    - 데이터 중복이 없다.
  - 구현 테이블 상속
    - 데이터를 중복한다.
    - 계층에 하나의 클래스를 둔다.
    - 조인 없이 한 객체를 한 테이블에서 가져올 수 있지만 변경에 취약하다.
  - 필다는 단일 테이블 상속을 선호한다고 한다. (데이터베이스의 공간 압축)

## 매핑
- 스키마를 직접 만들 경우
  - 도메인 논리가 단순한 경우 트랜젝션 스크립트나 테이블 모듈로 도메인 논리를 표현하고 게이트웨이를 사용한다.
  - 도메인 모델을 사용하는 경우 데이터베이스를 염두하지 않고 설계한다.
  - 도메인 논리가 좀 단순하고 데이터베이스 설계가 도메인 모델과 같다면 활성 레코드를 고려해본다.
- 도메인 논리는 데이터베이스가 고려되야 하며 장기간 도메인 모델만 가지고 개발하는 것은 위험하다.
- 스키마가 이미 있는 경우는 행 데이터 게이트웨이나 테이블 데이터 게이트웨이를 만들고 그 위에 도메인 논리를
  만든다. 도메인 모델을 점진적으로 구축하면서 복잡해지는 경우 데이터 매퍼를 사용한다.
- 둘 이상의 데이터 소스를 하나의 데이터 소스처럼 다뤄야할 때 이중 매핑을 사용할 수 있다.

## 메타데이터 사용

메타데이터 매핑으로 매핑 정보를 파일로 분리하면 반복 코드를 줄일 수 있다.

## 데이터베이스 연결

- 연결 비용을 줄이기 위해 데이터베이스 풀을 사용한다.
- 연결을 인자로 전달하거나 스레드 범위의 레지스트리를 사용한다.
- 연결을 가져오거나 반납하는 것은 트랜잭션 시작/커밋 시점과 맞추는 것이 좋다.

## 기타

- `select *`을 사용하는 경우 컬럼 순서가 중요한 경우 문제가 될 수 있다. 컬럼명으로 가져올 때는 괜찮다.
- SQL은 사전 컴파일을 하는 것이 좋고 문자열 concat을 하지 않는 것이 좋다.
- ROW 번호를 사용하는 경우도 주의 해야한다.
